<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magic Christmas - Pro Multi-Layer</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { width: 100%; height: 100vh; display: block; }
        #ui-layer { position: absolute; bottom: 30px; width: 100%; text-align: center; pointer-events: none; z-index: 100; }
        .guide { color: rgba(255, 255, 255, 0.6); font-size: 13px; margin-bottom: 20px; text-shadow: 0 2px 4px black; }
        button {
            pointer-events: auto; cursor: pointer; background: linear-gradient(to bottom, #D32F2F, #8B0000); 
            color: #FFF; border: 2px solid #FFD700; padding: 15px 50px; border-radius: 30px; 
            font-weight: 800; font-size: 16px; box-shadow: 0 0 30px rgba(255, 0, 0, 0.6); animation: pulse 1.5s infinite;
        }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }
        #camera-preview { position: absolute; top: 15px; right: 15px; width: 120px; height: 90px; border: 2px solid rgba(255,0,0,0.5); transform: scaleX(-1); opacity: 0.6; border-radius: 8px; }
        #copyright { position: absolute; bottom: 10px; right: 15px; color: rgba(255, 255, 255, 0.3); font-size: 12px; z-index: 100; pointer-events: none; font-style: italic; }
    </style>
</head>
<body>
    <script>
        (function() {
            var password = prompt("H√© looo! Nh·∫≠p m·∫≠t kh·∫©u ƒë·ªÉ xem qu√† t·ª´ Ng·ªçc Th·∫Øng nh√©:", "");
            if (password !== "270707") {
                alert("Sai m·∫≠t kh·∫©u!");
                document.body.innerHTML = "<div style='color:white; text-align:center; margin-top:20%;'><h1>Truy c·∫≠p b·ªã t·ª´ ch·ªëi</h1></div>";
                window.stop(); 
            }
        })();
    </script>

    <div id="ui-layer">
        <div class="guide">
            üñê <b>Open:</b> Explode &nbsp;|&nbsp; &#x1FAF6; <b>Heart:</b> Love &nbsp;|&nbsp; ‚úä <b>Fist:</b> Tree &nbsp;|&nbsp; üëå <b>OK:</b> Zoom In
        </div>
        <button id="btnStart" onclick="startSystem()">START MAGIC</button>
    </div>

    <div id="copyright">¬© by <i>NgocThang</i></div>
    <div id="canvas-container"></div>
    <video class="input_video" style="display:none"></video>
    <canvas id="camera-preview"></canvas>

    <script>
        const MUSIC_URL = "./audio.mp3";
        let bgMusic = new Audio(MUSIC_URL); bgMusic.loop = true;

        const photoFiles = [
            './image1.jpeg', './image2.jpeg', './image3.jpeg', './image4.jpeg', './image5.jpeg',
            './image6.jpeg', './image7.jpeg', './image8.jpeg', './image9.jpeg', './image10.jpeg'
        ];

        const loader = new THREE.TextureLoader();
        const photoTextures = photoFiles.map(f => loader.load(f));

        function createCustomTexture(type) {
            const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grd = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            if (type === 'snow') {
                grd.addColorStop(0, 'rgba(255, 255, 255, 1)'); grd.addColorStop(1, 'rgba(255, 255, 255, 0)');
            } else {
                grd.addColorStop(0, '#FFFFFF'); grd.addColorStop(0.5, type === 'red' ? '#FF0000' : '#FFD700'); grd.addColorStop(1, 'rgba(0,0,0,0)');
            }
            ctx.fillStyle = grd; ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        const textures = { gold: createCustomTexture('gold'), red: createCustomTexture('red'), snow: createCustomTexture('snow') };

        let scene, camera, renderer, groupGold, groupRed, snowSystem;
        let photoMeshes = [], titleMesh, starMesh, loveMesh;
        let state = 'TREE', selectedIndex = 0;
        let handX = 0.5, handY = 0.5, smoothedX = 0.5, smoothedY = 0.5;

        function init3D() {
            scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x000000, 0.002);
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.z = 100;
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            groupGold = createParticleSystem('gold', 2000, 1.5);
            groupRed = createParticleSystem('red', 300, 2.5);
            createSnow(); createPhotos(); createDecorations(); animate();
        }

        function createSnow() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for (let i = 0; i < 1500; i++) pos.push(Math.random()*200-100, Math.random()*200-100, Math.random()*200-100);
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            snowSystem = new THREE.Points(geo, new THREE.PointsMaterial({ size: 0.8, map: textures.snow, transparent: true, opacity: 0.6, depthWrite: false }));
            scene.add(snowSystem);
        }

        function createParticleSystem(type, count, size) {
            const pPos = [], pExp = [], pTree = [], pHeart = [];
            for(let i=0; i<count; i++) {
                const h = Math.random()*70; const y = h-35;
                const r = (1-(h/70))*35*(type==='gold'?Math.sqrt(Math.random()):1);
                const t = Math.random()*Math.PI*2;
                pTree.push(r*Math.cos(t), y, r*Math.sin(t));
                const phi = Math.acos(2*Math.random()-1), lam = 2*Math.PI*Math.random();
                const rad = 65*Math.cbrt(Math.random());
                pExp.push(rad*Math.sin(phi)*Math.cos(lam), rad*Math.sin(phi)*Math.sin(lam), rad*Math.cos(phi));
                const tH = Math.random()*Math.PI*2;
                pHeart.push(16*Math.pow(Math.sin(tH),3)*2.2, (13*Math.cos(tH)-5*Math.cos(2*tH)-2*Math.cos(3*tH)-Math.cos(4*tH))*2.2+5, (Math.random()-0.5)*8);
                pPos.push(pTree[i*3], pTree[i*3+1], pTree[i*3+2]);
            }
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pPos, 3));
            geo.userData = { tree: pTree, explode: pExp, heart: pHeart };
            const points = new THREE.Points(geo, new THREE.PointsMaterial({ size: size, map: textures[type==='gold'?'gold':'red'], transparent: true, blending: THREE.AdditiveBlending, depthWrite: false }));
            scene.add(points); return points;
        }

        function createPhotos() {
            const geo = new THREE.PlaneGeometry(8, 8);
            for(let i=0; i<photoFiles.length; i++) {
                const mesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ map: photoTextures[i], side: THREE.DoubleSide }));
                const border = new THREE.Mesh(new THREE.PlaneGeometry(8.8, 8.8), new THREE.MeshBasicMaterial({ color: 0xFFD700 }));
                border.position.z = -0.05; mesh.add(border); mesh.visible = false; scene.add(mesh); photoMeshes.push(mesh);
            }
        }

        function createDecorations() {
            // MERRY CHRISTMAS Title
            const can = document.createElement('canvas'); can.width = 512; can.height = 128;
            const ctx = can.getContext('2d'); ctx.font = 'bold 50px serif'; ctx.fillStyle = '#FFD700'; ctx.textAlign = 'center';
            ctx.fillText("MERRY CHRISTMAS", 256, 80);
            titleMesh = new THREE.Mesh(new THREE.PlaneGeometry(50, 12), new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(can), transparent: true }));
            titleMesh.position.y = 45; scene.add(titleMesh);

            // I LOVE YOU Text (Hi·ªÉn th·ªã khi l√†m tr√°i tim)
            const loveCan = document.createElement('canvas'); loveCan.width = 512; loveCan.height = 128;
            const lCtx = loveCan.getContext('2d'); lCtx.font = 'bold 60px serif'; lCtx.fillStyle = '#FF69B4'; lCtx.textAlign = 'center';
            lCtx.fillText("I LOVE YOU ‚ù§Ô∏è", 256, 80);
            loveMesh = new THREE.Mesh(new THREE.PlaneGeometry(60, 15), new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(loveCan), transparent: true }));
            loveMesh.position.set(0, 0, 20); loveMesh.visible = false; scene.add(loveMesh);
        }

        function animate() {
            requestAnimationFrame(animate); const time = Date.now()*0.001;
            smoothedX += (handX - smoothedX) * 0.15;
            smoothedY += (handY - smoothedY) * 0.15;

            const snowPos = snowSystem.geometry.attributes.position.array;
            for(let i=1; i<snowPos.length; i+=3) { snowPos[i] -= 0.15; if(snowPos[i] < -100) snowPos[i] = 100; }
            snowSystem.geometry.attributes.position.needsUpdate = true;

            [groupGold, groupRed].forEach(g => {
                const pos = g.geometry.attributes.position.array;
                const targets = g.geometry.userData[state==='TREE'?'tree':(state==='HEART'?'heart':'explode')];
                for(let i=0; i<pos.length; i++) pos[i] += (targets[i] - pos[i]) * 0.08;
                g.geometry.attributes.position.needsUpdate = true;
                if(state==='TREE') g.rotation.y += 0.005;
                else if(state==='HEART') {
                    g.rotation.y = 0;
                    const s = 1 + Math.abs(Math.sin(time * 3)) * 0.1;
                    g.scale.setScalar(s);
                }
                else if(state==='EXPLODE') g.rotation.y += ((handX-0.5)*4 - g.rotation.y)*0.1;
            });

            // X·ª≠ l√Ω c√°c Mesh trang tr√≠
            titleMesh.visible = (state === 'TREE');
            loveMesh.visible = (state === 'HEART');
            if(loveMesh.visible) {
                const s = 1 + Math.abs(Math.sin(time*3))*0.15;
                loveMesh.scale.setScalar(s);
            }

            photoMeshes.forEach((mesh, i) => {
                if(state === 'EXPLODE') {
                    mesh.visible = true; 
                    const col = i % 5; const row = Math.floor(i / 5);
                    const angle = groupGold.rotation.y + col * (Math.PI*2/5);
                    let yPos = (row === 0) ? 0 : (row === 1 ? 20 : -20);
                    mesh.position.lerp(new THREE.Vector3(Math.sin(angle)*32, yPos + Math.sin(time+i)*2, Math.cos(angle)*32), 0.1);
                    mesh.lookAt(camera.position); mesh.scale.setScalar(i===selectedIndex?1.6:0.7);
                } else if(state === 'PHOTO' && i === selectedIndex) {
                    mesh.visible = true; mesh.position.lerp(new THREE.Vector3(0,0,60), 0.1); mesh.scale.setScalar(5); mesh.lookAt(camera.position);
                } else { mesh.visible = false; mesh.scale.setScalar(0); }
            });
            renderer.render(scene, camera);
        }

        function startSystem() {
            document.getElementById('btnStart').style.display = 'none';
            bgMusic.play(); init3D();
            const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
            hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            hands.onResults(res => {
                const camCtx = document.getElementById('camera-preview').getContext('2d');
                camCtx.clearRect(0,0,120,90); camCtx.drawImage(res.image, 0, 0, 120, 90);
                
                if(res.multiHandLandmarks.length === 2) {
                    const h1 = res.multiHandLandmarks[0], h2 = res.multiHandLandmarks[1];
                    const dist = Math.hypot(h1[8].x-h2[8].x, h1[8].y-h2[8].y);
                    if (dist < 0.15) { state = 'HEART'; return; }
                }

                if(res.multiHandLandmarks.length > 0) {
                    const lm = res.multiHandLandmarks[0]; 
                    handX = lm[9].x; handY = lm[9].y;
                    let openD = 0; [8,12,16,20].forEach(i => openD += Math.hypot(lm[i].x-lm[0].x, lm[i].y-lm[0].y));
                    const pinchD = Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y);
                    
                    if(pinchD < 0.08) state = 'PHOTO';
                    else if(openD/4 < 0.25) state = 'TREE';
                    else { 
                        state = 'EXPLODE'; 
                        let c = Math.max(0, Math.min(4, Math.floor((1-smoothedX)*5)));
                        let r = (smoothedY < 0.4) ? 1 : (smoothedY > 0.7 ? 2 : 0);
                        let target = c + (r * 5);
                        if (target < photoFiles.length) selectedIndex = target;
                    }
                } else state = 'TREE';
            });
            new Camera(document.querySelector('.input_video'), { onFrame: async () => await hands.send({image: document.querySelector('.input_video')}), width: 320, height: 240 }).start();
        }
    </script>
</body>
</html>